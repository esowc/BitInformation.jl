<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transformations · BitInformation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BitInformation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../bitinformation/">Bitwise information</a></li><li class="is-active"><a class="tocitem" href>Transformations</a><ul class="internal"><li><a class="tocitem" href="#Bit-transpose-(aka-shuffle)"><span>Bit transpose (aka shuffle)</span></a></li><li><a class="tocitem" href="#XOR-delta"><span>XOR delta</span></a></li><li><a class="tocitem" href="#Signed-exponent"><span>Signed exponent</span></a></li></ul></li><li><a class="tocitem" href="../rounding/">Rounding</a></li><li><a class="tocitem" href="../functions/">Function index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Transformations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transformations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/milankl/BitInformation.jl/blob/master/docs/src/transformations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bit-transformations"><a class="docs-heading-anchor" href="#Bit-transformations">Bit transformations</a><a id="Bit-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Bit-transformations" title="Permalink"></a></h1><p>BitInformation.jl implements several bit transformations, meaning reversible, bitwise operations on scalars or arrays that reorder or transform the bits. This is often used to pre-process the data to make it more suitable for lossless compression algorithms.</p><div class="admonition is-warning"><header class="admonition-header">Interpretation of transformed floats</header><div class="admonition-body"><p>BitInformation.jl will not store the information that a transformation was applied to a value. This means that Julia will not know about this and interpret a value incorrectly. You will have to explicitly execute the backtransform </p><pre><code class="language-julia">julia&gt; A = [0f0,1f0]         # 0 and 1
julia&gt; At = bittranspose(A)  # are transposed into 1f-35 and 0
2-element Vector{Float32}:
1.0026967f-35
0.0</code></pre></div></div><h2 id="Bit-transpose-(aka-shuffle)"><a class="docs-heading-anchor" href="#Bit-transpose-(aka-shuffle)">Bit transpose (aka shuffle)</a><a id="Bit-transpose-(aka-shuffle)-1"></a><a class="docs-heading-anchor-permalink" href="#Bit-transpose-(aka-shuffle)" title="Permalink"></a></h2><p>Bit shuffle operations re-order the bits or bytes in an array, such that bits or each element in that array are placed next to each other in memory. Despite the name, this operation is often called &quot;shuffle&quot;, although there is nothing random about this, and it is perfectly reversible. Here, we call it bit transpose, as for an array with <span>$n$</span> elements of each <span>$n$</span> bits, this is equivalent to the matrix tranpose</p><pre><code class="language-julia">julia&gt; A = rand(UInt8,8);
julia&gt; bitstring.(A)
8-element Array{String,1}:
 &quot;10101011&quot;
 &quot;11100000&quot;
 &quot;11010110&quot;
 &quot;10001101&quot;
 &quot;10000010&quot;
 &quot;00011110&quot;
 &quot;11111100&quot;
 &quot;00011011&quot;

julia&gt; At = bittranspose(A);
julia&gt; bitstring.(At)
8-element Array{String,1}:
 &quot;11111010&quot;
 &quot;01100010&quot;
 &quot;11000010&quot;
 &quot;00100111&quot;
 &quot;10010111&quot;
 &quot;00110110&quot;
 &quot;10101101&quot;
 &quot;10010001&quot;</code></pre><p>In general, we can bittranspose <span>$n$</span>-element arrays with <span>$m$</span> bits bits per element, which corresponds to a reshaped transpose. For floats, bittranspose will place all the sign bits next to each other in memory, then all the first exponent bits and so on. Often this creates a better compressible array, as bits with similar meaning (and often the same state in correlated data) are placed next to each other.</p><pre><code class="language-julia">julia&gt; A = rand(Float32,10);
julia&gt; Ar = round(A,7);

julia&gt; bitstring.(bittranspose(Ar))
10-element Array{String,1}:
 &quot;00000000000000000000111111111111&quot;
 &quot;11111111111111111111111111111011&quot;
 &quot;11111101100001011100111010000001&quot;
 &quot;00111000001010001010100111101001&quot;
 &quot;00000101011101110110000101100010&quot;
 &quot;00000000000000000000000000000000&quot;
 &quot;00000000000000000000000000000000&quot;
 &quot;00000000000000000000000000000000&quot;
 &quot;00000000000000000000000000000000&quot;
 &quot;00000000000000000000000000000000&quot;</code></pre><p>Now all the sign bits are in the first row, and so on. Using <code>round</code> means that all the zeros from rounding are now placed at the end of the array. The <code>bittranspose</code> function can be reversed by <code>bitbacktranspose</code>:</p><pre><code class="language-julia">julia&gt; A = rand(Float32,123,234);

julia&gt; A == bitbacktranspose(bittranspose(A))
true</code></pre><p>Both accept arrays of any shape for <code>UInt</code>s as well as floats.</p><h2 id="XOR-delta"><a class="docs-heading-anchor" href="#XOR-delta">XOR delta</a><a id="XOR-delta-1"></a><a class="docs-heading-anchor-permalink" href="#XOR-delta" title="Permalink"></a></h2><p>Instead of storing every element in an array as itself, you may want to store the difference to the previous value. For bits this &quot;difference&quot; generalises to the reversible xor-operation. The <code>xor_delta</code> function applies this operation to a <code>UInt</code> or <code>Float</code> array:</p><pre><code class="language-julia">julia&gt; A = rand(UInt16,4)
4-element Array{UInt16,1}:
 0x2569
 0x97d2
 0x7274
 0x4783

julia&gt; xor_delta(A)
4-element Array{UInt16,1}:
 0x2569
 0xb2bb
 0xe5a6
 0x35f7</code></pre><p>And is reversible with <code>unxor_delta</code>.</p><pre><code class="language-none">julia&gt; A == unxor_delta(xor_delta(A))
true</code></pre><p>This method is interesting for correlated data, as many bits will be 0 in the XORed array:</p><pre><code class="language-julia">julia&gt; A = sort(1 .+ rand(Float32,100000));
julia&gt; Ax = xor_delta(A);
julia&gt; bitstring.(Ax)
100000-element Array{String,1}:
 &quot;00111111100000000000000000000101&quot;
 &quot;00000000000000000000000010110011&quot;
 &quot;00000000000000000000000000001000&quot;
 &quot;00000000000000000000000001101110&quot;
 &quot;00000000000000000000000101101001&quot;
 &quot;00000000000000000000000001101100&quot;
 &quot;00000000000000000000001111011000&quot;
 &quot;00000000000000000000000010001101&quot;
 ⋮</code></pre><h2 id="Signed-exponent"><a class="docs-heading-anchor" href="#Signed-exponent">Signed exponent</a><a id="Signed-exponent-1"></a><a class="docs-heading-anchor-permalink" href="#Signed-exponent" title="Permalink"></a></h2><p>Floating-point numbers have a biased exponent. There are  <a href="https://en.wikipedia.org/wiki/Signed_number_representations#Comparison_table">other ways to encode the exponent</a> and BitInformation.jl implements <code>signed_exponent</code> which transforms the exponent bits of a float into a  representation where also the exponent has a sign bit (which is the first exponent bit)</p><pre><code class="language-julia">julia&gt; a = [0.5f0,1.5f0]               # smaller than 1 (exp sign -1), larger than 1 (exp sign +1)
julia&gt; bitstring.(a,:split)
2-element Vector{String}:
 &quot;0 01111110 00000000000000000000000&quot;  # biased exponent: 2^(e-bias) = 2^-1 here
 &quot;0 01111111 10000000000000000000000&quot;  # biased exponent: 2^(e-bias) = 2^0 here

julia&gt; bitstring.(signed_exponent(a),:split)
2-element Vector{String}:
 &quot;0 10000001 00000000000000000000000&quot;  # signed exponent: sign=1, magnitude=1, i.e. 2^-1
 &quot;0 00000000 10000000000000000000000&quot;  # signed exponent: sign=0, magnitude=0, i.e. 2^0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bitinformation/">« Bitwise information</a><a class="docs-footer-nextpage" href="../rounding/">Rounding »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 December 2021 16:17">Wednesday 8 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
